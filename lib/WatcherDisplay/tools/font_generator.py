#!/usr/bin/env python3
"""
E-Paper Bitmap Font Generator
Converts TTF/OTF fonts to C arrays for Arduino e-paper displays

Usage: python font_generator.py <font.ttf> <size> <output_name> [--output-dir <dir>]
"""

import sys
import os
import argparse
from pathlib import Path
from PIL import Image, ImageDraw, ImageFont

def generate_font_bitmap(font_path, font_height, output_name, output_dir="output", 
                         start_char=0x20, end_char=0x7E):
    """Generate bitmap font with proper alignment"""
    
    if not os.path.exists(font_path):
        raise FileNotFoundError(f"Font file not found: {font_path}")
    
    try:
        font = ImageFont.truetype(font_path, font_height)
    except Exception as e:
        raise RuntimeError(f"Failed to load font: {e}")
    
    # Test canvas
    test_img = Image.new('1', (font_height * 3, font_height * 3), 1)
    test_draw = ImageDraw.Draw(test_img)
    
    # Measure width
    bbox_m = test_draw.textbbox((0, 0), 'M', font=font)
    char_width = bbox_m[2] - bbox_m[0]
    
    bbox_i = test_draw.textbbox((0, 0), 'i', font=font)
    width_i = bbox_i[2] - bbox_i[0]
    
    is_monospace = abs(char_width - width_i) < 2
    
    font_width = char_width
    width_bytes = (font_width + 7) // 8
    
    # Measure character bounds
    all_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789gjpqy!@#$%"
    min_y = 999
    max_y = -999
    
    for char in all_chars:
        try:
            bbox = test_draw.textbbox((0, 0), char, font=font)
            min_y = min(min_y, bbox[1])
            max_y = max(max_y, bbox[3])
        except:
            continue
    
    natural_height = max_y - min_y
    
    # Calculate vertical offset
    if natural_height <= font_height:
        y_offset = (font_height - natural_height) // 2 - min_y
    else:
        y_offset = -min_y
    
    # Generate bitmaps
    font_data = []
    
    for ascii_code in range(start_char, end_char + 1):
        char = chr(ascii_code)
        
        # Create canvas
        img = Image.new('1', (font_width, font_height), 1)
        draw = ImageDraw.Draw(img)
        
        try:
            # Get char bbox
            bbox = draw.textbbox((0, 0), char, font=font)
            char_pixel_width = bbox[2] - bbox[0]
            
            # Center horizontally
            x_pos = (font_width - char_pixel_width) // 2
            
            # Use calculated y_offset
            draw.text((x_pos, y_offset), char, font=font, fill=0)
            
        except:
            pass  # Blank on error
        
        # Convert to bytes
        char_bytes = []
        pixels = img.load()
        
        for y in range(font_height):
            for byte_col in range(width_bytes):
                byte_val = 0
                for bit in range(8):
                    x = byte_col * 8 + bit
                    if x < font_width:
                        if pixels[x, y] == 0:
                            byte_val |= (1 << (7 - bit))
                char_bytes.append(byte_val)
        
        font_data.append((char, char_bytes))
    
    # Create output directory
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Write .cpp file
    cpp_filename = output_path / f"{output_name}.cpp"
    
    with open(cpp_filename, 'w', encoding='utf-8') as f:
        f.write(f"""/**
  ******************************************************************************
  * @file    {output_name}.cpp
  * @brief   {font_height}px bitmap font for e-paper displays
  * @note    Generated by E-Paper Font Generator
  *          Source: {os.path.basename(font_path)}
  *          Dimensions: {font_width}×{font_height} pixels
  *          Type: {'Monospace' if is_monospace else 'Proportional'}
  *          Natural height: {natural_height}px
  *          Y offset: {y_offset}px
  *          Character set: ASCII 0x{start_char:02X}-0x{end_char:02X} (95 chars)
  ******************************************************************************
  */

#include "fonts.h"

const uint8_t {output_name}_Table[] = 
{{
""")
        
        for char, char_bytes in font_data:
            char_display = char if char.isprintable() and char != '\\' else f"0x{ord(char):02X}"
            f.write(f"\t// @{(ord(char) - start_char) * len(char_bytes)} '{char_display}'\n")
            
            for row in range(font_height):
                row_bytes = char_bytes[row * width_bytes:(row + 1) * width_bytes]
                
                visual = ""
                for byte_val in row_bytes:
                    for bit in range(8):
                        if byte_val & (1 << (7 - bit)):
                            visual += "#"
                        else:
                            visual += " "
                visual = visual[:font_width]
                
                f.write("\t")
                for byte_val in row_bytes:
                    f.write(f"0x{byte_val:02X}, ")
                f.write(f" // {visual}\n")
            
            f.write("\n")
        
        f.write(f"""}};\n
sFONT {output_name} = {{
  {output_name}_Table,
  {font_width}, /* Width */
  {font_height}, /* Height */
}};

/************************ END OF FILE ****/
""")
    
    # Write .h file
    h_filename = output_path / f"{output_name}.h"
    guard_name = f"__{output_name.upper()}_H__"
    
    with open(h_filename, 'w', encoding='utf-8') as f:
        f.write(f"""/**
  ******************************************************************************
  * @file    {output_name}.h
  * @brief   {font_height}px bitmap font header
  * @note    Generated by E-Paper Font Generator
  ******************************************************************************
  */

#ifndef {guard_name}
#define {guard_name}

#ifdef __cplusplus
extern "C" {{
#endif

#include "fonts.h"

extern sFONT {output_name};

#ifdef __cplusplus
}}
#endif

#endif /* {guard_name} */
""")
    
    # Calculate memory
    total_bytes = len(font_data) * len(font_data[0][1])
    
    return {
        'cpp_file': str(cpp_filename),
        'h_file': str(h_filename),
        'width': font_width,
        'height': font_height,
        'natural_height': natural_height,
        'is_monospace': is_monospace,
        'memory_bytes': total_bytes,
        'memory_kb': total_bytes / 1024
    }


def main():
    parser = argparse.ArgumentParser(
        description='E-Paper Bitmap Font Generator',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python font_generator.py Monocraft.ttf 16 FontMinecraft16
  python font_generator.py Roboto.ttf 24 FontRoboto24 --output-dir output/Roboto
        """
    )
    
    parser.add_argument('font_file', help='Font file (TTF/OTF)')
    parser.add_argument('height', type=int, help='Height in pixels (8-128)')
    parser.add_argument('output_name', help='Output name (e.g., FontName16)')
    parser.add_argument('--output-dir', default='output', help='Output directory')
    parser.add_argument('--start', type=lambda x: int(x, 0), default=0x20,
                        help='Start ASCII code (default: 0x20)')
    parser.add_argument('--end', type=lambda x: int(x, 0), default=0x7E,
                        help='End ASCII code (default: 0x7E)')
    parser.add_argument('--quiet', action='store_true', help='Minimal output')
    
    args = parser.parse_args()
    
    # Validation
    if args.height < 8 or args.height > 128:
        print(f"ERROR: Height must be 8-128 pixels")
        sys.exit(1)
    
    if args.start < 0 or args.start > 127:
        print(f"ERROR: Start character must be 0-127")
        sys.exit(1)
    
    if args.end < args.start or args.end > 127:
        print(f"ERROR: End character must be >= start and <= 127")
        sys.exit(1)
    
    # Generate
    try:
        if not args.quiet:
            print(f"[*] Generating {args.output_name} from {args.font_file}...")
        
        result = generate_font_bitmap(
            args.font_file,
            args.height,
            args.output_name,
            args.output_dir,
            args.start,
            args.end
        )
        
        if not args.quiet:
            print(f"[✓] Success!")
            print(f"    Files: {result['cpp_file']}, {result['h_file']}")
            print(f"    Size: {result['width']}×{result['height']}px")
            print(f"    Type: {'Monospace' if result['is_monospace'] else 'Proportional'}")
            print(f"    Memory: {result['memory_kb']:.2f} KB")
        
    except Exception as e:
        print(f"[✗] ERROR: {e}")
        sys.exit(1)


if __name__ == '__main__':
    main()
