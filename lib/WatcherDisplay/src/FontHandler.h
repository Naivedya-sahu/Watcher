/**
 * FontHandler - Custom Font Manager for WatcherDisplay
 *
 * Manages custom TTF/OTF fonts generated by the E-Paper Font Generator
 * Provides easy registration and usage of custom bitmap fonts
 *
 * Features:
 * - Register multiple custom fonts at runtime
 * - Font size variants management
 * - Memory-efficient font storage
 * - Integration with font_generator.py workflow
 * - Font caching and lookup
 */

#ifndef FONT_HANDLER_H
#define FONT_HANDLER_H

#include <Arduino.h>
#include "fonts.h"

// Maximum number of custom fonts that can be registered
#ifndef MAX_CUSTOM_FONTS
#define MAX_CUSTOM_FONTS 20
#endif

/**
 * CustomFontEntry - Represents a registered custom font
 */
struct CustomFontEntry {
    const char* name;        // Font name (e.g., "Monocraft")
    uint8_t size;            // Font size in pixels
    sFONT* font;             // Pointer to sFONT structure
    bool active;             // Whether this slot is in use

    CustomFontEntry() : name(nullptr), size(0), font(nullptr), active(false) {}
};

/**
 * FontHandler - Custom font registry and manager
 */
class FontHandler {
public:
    /**
     * Get singleton instance
     */
    static FontHandler& getInstance() {
        static FontHandler instance;
        return instance;
    }

    /**
     * Register a custom font
     * @param name Font name (e.g., "Monocraft", "IBMPlex")
     * @param size Font size in pixels
     * @param font Pointer to sFONT structure
     * @return true if registered successfully
     */
    bool registerFont(const char* name, uint8_t size, sFONT* font);

    /**
     * Get a font by name and size
     * @param name Font name
     * @param size Font size (0 = any size, returns first match)
     * @return Pointer to sFONT or nullptr if not found
     */
    sFONT* getFont(const char* name, uint8_t size = 0);

    /**
     * Check if a font is registered
     * @param name Font name
     * @param size Font size (0 = any size)
     * @return true if font exists
     */
    bool hasFont(const char* name, uint8_t size = 0);

    /**
     * Unregister a font
     * @param name Font name
     * @param size Font size (0 = unregister all sizes)
     */
    void unregisterFont(const char* name, uint8_t size = 0);

    /**
     * Unregister all fonts
     */
    void clear();

    /**
     * Get number of registered fonts
     */
    uint8_t getCount() const { return fontCount; }

    /**
     * List all registered fonts (debug)
     */
    void listFonts() const;

    /**
     * Get font at index (for iteration)
     * @param index Font index (0 to getCount()-1)
     * @return CustomFontEntry or nullptr if invalid index
     */
    const CustomFontEntry* getFontAt(uint8_t index) const;

private:
    FontHandler() : fontCount(0) {
        for (int i = 0; i < MAX_CUSTOM_FONTS; i++) {
            fonts[i].active = false;
        }
    }

    // Prevent copying
    FontHandler(const FontHandler&) = delete;
    FontHandler& operator=(const FontHandler&) = delete;

    CustomFontEntry fonts[MAX_CUSTOM_FONTS];
    uint8_t fontCount;

    // Helper to find free slot
    int findFreeSlot();

    // Helper to find font index
    int findFont(const char* name, uint8_t size);
};

/**
 * FONT_REGISTER - Macro for easy font registration
 * Use this in your sketch setup() to register custom fonts
 *
 * Example:
 *   FONT_REGISTER("Monocraft", 16, FontMonocraft16);
 *   FONT_REGISTER("Monocraft", 24, FontMonocraft24);
 */
#define FONT_REGISTER(name, size, fontVar) \
    FontHandler::getInstance().registerFont(name, size, &fontVar)

/**
 * FONT_GET - Macro for easy font retrieval
 *
 * Example:
 *   sFONT* myFont = FONT_GET("Monocraft", 16);
 */
#define FONT_GET(name, size) \
    FontHandler::getInstance().getFont(name, size)

#endif // FONT_HANDLER_H
